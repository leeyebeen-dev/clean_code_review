# 1️⃣ 작게 만들어라!

함수는 최대한 작게! 만든다.
100줄을 넘어서는 안 된다. 20줄도 길다. 2-5줄 이내로 줄이자.

### 블록과 들여쓰기

if 문 / else 문 / while 문 등에 들어가는 블록은 한 줄이어야 한다.
중첩 구조가 생길 만큼 함수가 커져서는 안 된다.
함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

---

# 2️⃣ 한 가지만 해라!

함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. → 함수는 한 가지 작업만 한다.

### 함수 내 섹션
한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

---

# 3️⃣ 함수 당 추상화 수준은 하나로!

함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

    getHtml() >> 추상화 수준이 아주 높다.
   
    String pagePathName = PathParser.render(pagepath);
    >> 추상화 수준이 중간이다.
   
    .append("\n") >> 추상화 수준이 아주 낮다.

### 위에서 아래로 코드 읽기 : 내려가기 규칙
코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. → 내려가기 규칙

---

# 4️⃣ Switch문

switch문은 작게 만들기 어렵다. → 한 가지 작업만 하는 switch 문도 어렵다.
본질적으로 switch 문은 N가지 처리한다.
다형성을 이용해 각 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법이다.
상황에 따라서 사용한다.

---

# 5️⃣ 서술적인 이름을 사용하라!

> 코드를 읽으며 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. _ 워드

함수가 작고 단순할수록 서술적인 이름을 고르기 쉬워진다.
서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
이름을 붙일 때는 일관성이 있어야 한다.

---

# 6️⃣ 함수 인수

함수에서 이상적인 인수 개수는 0개(무항)다.

### 많이 쓰는 단항 형식

함수에 인수 1개를 넘기는 이유

* 인수에 질문을 던지는 경우
    → `boolean fileExists(”MyFile”)`
* 인수를 뭔가로 변환해 결과를 반환하는 경우
    → `InputStream fileOpen(”MyFile”)`

##### 이벤트 함수
(입력 인수만 있다. 출력 인수는 없다. 이벤트라는 사실이 코드에 명확히 드러나야 한다.)

⇒ 위의 경우가 아니라면 단항 함수는 가급적 피한다.

### 플래그 인수
플래그 인수는 추하다.
→ 참인지 거짓인지에 따라 두 가지 일을 한다.

함수로 bool 값을 넘기는 관례
→ 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이다.

### 이항 함수
직교 좌표계 점은 일반적으로 인수 2개를 취한다. (인수 2개 함수 조건)
→ 여기서 인수 2개는 한 값을 표현하는 두 요소이다.
→ 두 요소에는 자연적인 순서도 있다.
나쁜 것은 아니지만 위험이 따르기 때문에 가능하면 단항 함수로 바꾸도록 애써야 한다.

### 삼항 함수
순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다.
삼항 함수는 신중히 고려할 필요가 있다.

### 인수 객체
인수가 2 - 3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.

### 인수 목록
때로는 인수 개수가 가변적인 함수도 필요하다.

    String.format("%s worked %.2f hours.", name, hours);
    
    >> 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할
    수 있다. 사실상 이항 함수.
    
    >> 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급 가능
    but 이를 넘어서는 인수 사용은 문제가 있음.
    
### 동사와 키워드
단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
→ `writeField(name)`

함수 이름에 키워드(인수 이름)를 추가하는 형식이다.
→ `assertEquals` 보다 `assertExpectedEqualsActual(expected, actual)`
⇒ 인수 순서를 기억할 필요가 없어진다

---

# 7️⃣ 부수 효과를 일으키지 마라!

부수 효과는 거짓말이다.

함수에서 한 가지를 하겠다고 약속하고 다른 것도 한다.
(때로는 클래스 변수 수정, 함수로 넘어온 인수나 시스템 전역 변수 수정)
⇒ 시간적인 결합이나 순서 종속성 초래

> 부수 효과(side effect)
: 값을 변환하는 메서드나 함수가 외부 상태를 변경하는 경우
(원래의 목적과 다르게 다른 효과 또는 부작용이 나타나는 상태)

### 출력 인수
일반적으로 인수를 함수 입력으로 해석한다.
일반적으로 출력 인수는 피해야 한다.
함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 선택한다.

---

# 8️⃣ 명령과 조회를 분리하라!

객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나만 해야 한다.

---

# 9️⃣ 오류 코드보다 예외를 사용하라!

오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

### Try / Catch 블록 뽑아내기

    try {
    ...
    } catch(Exception e) {
    ...
    }

try / catch 블록은 원래 추하다.<br>
코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.<br>
→ try / catch 블록을 별도 함수로 뽑아내는 게 좋다.

### 오류 처리도 한 가지 작업이다.

함수는 한 가지 작업만 → 오류 처리도 한 가지 작업에 속한다.

⇒ 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

### Error . java 의존성 자석

---

# 1️⃣0️⃣ 반복하지 마라!

중복은 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하며 오류가 발생할 확률도 높다.
중복은 제거하도록 노력해야 한다.

---

# 1️⃣1️⃣ 구조적 프로그래밍

데이크스트라 → 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.

함수는 return문이 하나여야 한다.

루프 안에서 break나 continue를 사용해선 안 되며, goto는 절대로 안 된다.
⇒ 함수가 클 경우 이익 제공

함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다.

반면 goto 문은 큰 함수에서만 의미가 있으므로 작은 함수에서는 피해야만 한다.

---
